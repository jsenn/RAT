include("util.jl")

using SampledSignals

"""
    urnseqi(i, qlarge, qsmall, period, phase=1)

If the given index `i` coincides with the given `phase` and `period`, returns 1
with probability `qlarge`. Otherwise, returns 1 with probability `qsmall`.
"""
function urnseqi(i, qlarge, qsmall, period, phase=1)
    @assert(phase >= 0 && phase <= period)
    phase = phase % period
    return i % period == phase ? bernoulli(qlarge) : bernoulli(qsmall)
end

"""
    urnseq(length, qlarge, qsmall, period, phase)

Returns a random repetitive sequence generated by sampling from 2 Bernoulli
random variables with probabilities `qlarge` and `qsmall`. Every `period` entries,
a 1 appears with probability `qlarge` (otherwise 0). In between, the value is 1
with probability `qsmall`.

See Rhythm and Transforms p. 179-180
"""
function urnseq(length, qlarge, qsmall, period, phase=1)
    return [urnseqi(i, qlarge, qsmall, period, phase) for i=1:length]
end

function urnseq_ll(seq, qlarge, qsmall, period, phase)
    phase = phase % period

    num_ones_large = 0
    num_zeros_large = 0
    num_ones_small = 0
    num_zeros_small = 0
    for i = 1:lastindex(seq)
        if i % period == phase
            if seq[i] == 1
                num_ones_large += 1
            else
                num_zeros_large += 1
            end
        else
            if seq[i] == 1
                num_ones_small += 1
            else
                num_zeros_small += 1
            end
        end
    end

    # Since the larges and smalls are repeated Bernoulli trials, the
    # probability of observing n 1s and m 0s is p^n(1-p)^m, where p
    # is either `qlarge` or `qsmall`, respectively. Since the larges
    # and smalls are assumed independent, the overall probability of
    # observing `seq` is obtained by multiplying the terms together.
    # The log of each term is of the form nlog(p) + mlog(1-p).
    function ll(p, num_ones, num_zeros)
        return num_ones*log(p) + num_zeros*log(1-p)
    end

    ll_large = ll(qlarge, num_ones_large, num_zeros_large)
    ll_small = ll(qsmall, num_ones_small, num_zeros_small)

    return ll_large + ll_small
end

function urnseq2q(t, qlarge, qsmall, period, phase; width=period/20)
    phase = phase % period
    # TODO: this is asymmetrical if right on a spike, but the
    #       contribution of the next spike should be ~0 anyway...
    prev_spike_idx = div((t-phase), period)
    next_spike_idx = prev_spike_idx + 1
    tprev = phase + prev_spike_idx * period
    tnext = phase + next_spike_idx * period
    prevpulse = gaussianpulse(t; u=tprev, s=width, shift=0, height=qlarge-qsmall)
    nextpulse = gaussianpulse(t; u=tnext, s=width, shift=0, height=qlarge-qsmall)
    return qsmall + prevpulse + nextpulse
end

function urnseq2t(t, qlarge, qsmall, period, phase; width=period/20)
    prob = urnseq2q(t, qlarge, qsmall, period, phase; width=width)
    return bernoulli(prob)
end

"""
    urnseq2(duration, qlarge, qsmall, period, phase, width=period/20; samplerate=86)

This can be thought of as a version of urnseq() where the onsets don't always fall
exactly on grid points. To make that work, the sequence is defined in continuous
(sampled) time. Onsets will tend to cluster around grid points, but the clustering
will be inexact unless width is 0.

Unlike urnseq(), this returns a SampleBuf.

See Rhythm and Transforms p. 182-183
"""
function urnseq2(duration, qlarge, qsmall, period, phase, width=period/20; samplerate=86)
    length = Int(ceil(duration * samplerate))
    t = (0:length-1) / samplerate
    samples = urnseq2t.(t, qlarge, qsmall, period, phase; width=width)
    return SampleBuf(samples, samplerate)
end

function urnseq2_ll(buf, qlarge, qsmall, period, phase, width=period/20)
    t = (0:length(buf.data)-1)/buf.samplerate
    probs = urnseq2q.(t, qlarge, qsmall, period, phase; width=width)
    return sum(buf.data .* log.(probs) .+ (1 .- buf.data) .* log.(1 .- probs))
end